var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CloudSeis]\nOrder   = [:function, :type]","category":"page"},{"location":"reference/#Base.Filesystem.cp","page":"Reference","title":"Base.Filesystem.cp","text":"cp(src::CSeis, dst[, extents=:]; batch_size=32, workers=Distributed.workers)\n\nCopy a CloudSeis data-set to dst and where dst is either of type Container or of type Vector{Container}.  The latter is used for sharding data across multiple storage accounts.\n\nThe option extents can be used to copy a sub-set of the CloudSeis data extents (e.g. 1:10). The batch_size option allows extents to be copied in batches and where the number of extents associated with each batch is set via batch_size.  Within a batch, each extent is copied via an asynchronous task.\n\nThe cp method will be executed on the set of machines defined by workers.  Note that the work will be sent to the workers one batch at a time.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.Filesystem.mv-Tuple{CloudSeis.CSeis, Union{AbstractStorage.Container, Vector{<:AbstractStorage.Container}}}","page":"Reference","title":"Base.Filesystem.mv","text":"mv(src::CSeis, dst::Container; batch_size=32, workers=Distributed.workers)\n\nmove a CloudSeis data-set to dst and where dst is either of type Container or of type Vector{Container}.  See cp for a description of batch_size and workers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.Filesystem.rm-Tuple{CloudSeis.CSeis}","page":"Reference","title":"Base.Filesystem.rm","text":"rm(io::CSeis)\n\nDelete a CloudSeis data-set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.close-Tuple{CloudSeis.CSeis}","page":"Reference","title":"Base.close","text":"close(io::CSeis)\n\nClose a handle to a CloudSeis data-set.  This may also flush contents of the CloudSeis buffer to storage.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.copy!-Tuple{CloudSeis.CSeis, AbstractMatrix{UInt8}, CloudSeis.CSeis, AbstractMatrix{UInt8}}","page":"Reference","title":"Base.copy!","text":"copy!(ioout::CSeis, hdrsout::AbstractMatrix{UInt8}, ioin::CSeis, hdrsin::AbstractMatrix{UInt8})\n\ncopy headers from hdrsin to hdrsout, and where hdrsin are headers from a frame of ioin, and where hdrsout are headers from a frame of ioout.\n\nExample\n\nioin = csopen(AzContainer(\"mydataset-in-cs\";storageaccount=\"mystorageaccount\"))\nioout = csopen(AzContainer(\"mydataset-out-cs\";storageaccount=\"mystorageaccount\"))\n\nhdrsin = readframehdrs(ioin, 1)\nhdrsout = allocframehdrs(ioout)\ncopy!(ioout, hdrsout, ioin, hdrsin)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.empty!-Tuple{CloudSeis.CSeis}","page":"Reference","title":"Base.empty!","text":"empty!(io::CSeis)\n\nEmpty (i.e. delete the extents) from a CloudSeis data-set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.get-Tuple{CloudSeis.TraceProperty, AbstractMatrix{UInt8}, Integer}","page":"Reference","title":"Base.get","text":"get(prop::TraceProperty, hdrs::Matrix, i)\n\nReturns the vale of a trace header property for the ith column in the trace headers hdrs.\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nhdrs = readframehdrs(io, 1)\nget(prop(io, \"TRACE\"), hdrs, 1)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.get-Union{Tuple{T}, Tuple{CloudSeis.TraceProperty{T}, AbstractVector{UInt8}}} where T<:Number","page":"Reference","title":"Base.get","text":"get(prop::TraceProperty, hdr::Vector)\n\nReturns the vale of a trace header property for the trace header hdr.\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nhdrs = readframehdrs(io,1)\nhdr = @view hdrs[:,1]\nget(prop(io, \"TRACE\"), hdr)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.in-Tuple{CloudSeis.TracePropertyDef, CloudSeis.CSeis}","page":"Reference","title":"Base.in","text":"in(propdef::TracePropertyDef, io::CSeis)\n\nreturn true if propdef exists in the CloudSeis data-set, io.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.length-Tuple{CloudSeis.CSeis}","page":"Reference","title":"Base.length","text":"length(io::CSeis)\n\nReturn the total number of frames in a CloudSeis data-set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.ndims-Tuple{CloudSeis.CSeis}","page":"Reference","title":"Base.ndims","text":"ndims(io::CSeis)\n\nReturn the number of dimensions in a CloudSeis data-set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.reduce-Tuple{CloudSeis.CSeis}","page":"Reference","title":"Base.reduce","text":"reduce(io[; optional keyword arguments...])\n\nConsolodate data-set extents into fewer extents.\n\nOptional keyword arguments\n\nmbytes_per_extent=1000 set the size of each output extent via either the size of each extent\nframes_per_extent=0 set the size of each output extent via the number of frames allowed in each extent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.size-Tuple{CloudSeis.CSeis}","page":"Reference","title":"Base.size","text":"size(io::CSeis[,i])\n\nReturn the size of a CloudSeis data-set.  If i is specified, then return the size of dimension i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.write-Union{Tuple{N}, Tuple{CloudSeis.CSeis, AbstractArray, Vararg{Union{Colon, Int64, AbstractRange{Int64}}, N}}} where N","page":"Reference","title":"Base.write","text":"write(io::CSeis, trcs, rng...)\n\nWrite traces to io, and where the size and dimension of trcs must match the size and dimensions of rng....\n\nExample 1\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container, \"w\"; axis_length=[100,101,102])\nwrite(io, rand(Float32,100,101,102), :, :, :)\nclose(io)\n\nExample 2\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container, \"w\"; axis_lengths=[100,101,102])\nwrite(io, rand(Float32,100,50,1), :, 1:50, 1)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.cscreate-Tuple{Union{AbstractStorage.Container, Vector{<:AbstractStorage.Container}}}","page":"Reference","title":"CloudSeis.cscreate","text":"cscreate(containers[; optional keyword arguments...])\n\nCreate a new CloudSeis dataset without creating a corresponding handle and without opening the data-set.  Please see help for csopen for the optional keyword arguments.\n\ncontainers is either of type Container or Vector{<:Container}.  In the former case, all extents are stored in a single container, and in the later case, extents are sharded accross multiple containers.\n\nIn \"r\" and \"r+\" mode, and when the existing data-set is sharded over multiple containers, it is only required to supply the primary container.  The \"description.json\" object is in the \"primary\" container.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.csopen-Tuple{Vector{<:AbstractStorage.Container}, Any}","page":"Reference","title":"CloudSeis.csopen","text":"io = csopen(containers[, mode=\"r\"]; axis_lengths::Vector{Int}[, optional keyword arguments])\n\nreturns a handle to a CloudSeis data-set, and where container::Container corresponds to a dataset where all extents are in a single container, and  container::Vector{<:Container} corresponds to a dataset where extents are sharded across mulitple containers.  The container(s) can be either POSIX folders (container::Folder), or cloud storage container (e.g. container::AzContainer).\n\nmode is one of \"r\" - read, \"w\" - write, \"r+\" - open existing data-set for reading and writing.\n\nIf mode=\"w\", then axis_lenghts is a required key-word argument.  axis_lengths specifies the size of the container.  The axis_lengths vector is of at-least length 3.\n\nOptional keyword arguments\n\nsimilarto::String An existing CloudSeis dataset.  If set, then all other named arguments can be used to modify the data context that belongs to the existing CloudSeis dataset.\nhistory history dictionary (see notes, below, for how it should be formatted/constructed).\ndatatype::String Examples are CMP, SHOT, etc.  If not set, then UNKNOWN is used.\ntraceformat::DataType=Float32 Not supported.  We have only tested against traceformat=Float32.\nbyteorder::String\nextents::Vector{UnitRange} List of integer ranges (frame range) for each extent.  Each extent maps to an object in block storage (set only one of extents, frames_per_extent and mbytes_per_extent).\nframes_per_extent::Int Nominal number of frames per extent (set only one of extents, frames_per_extent and mbytes_per_extent).\nmbytes_per_extent::Int Nominal size of each extent in units of mega-bytes (set only one of extents, frames_per_extent and mbytes_per_extent).\ngeometry::Geometry An optional three point geometry can be embedded in the CloudSeis file.\ntracepropertydefs::Vector{TracePropertyDef} An array of trace property definitions.   These are in addition to the axes property definitions.\ndataproperties::Vector{DataProperty} An array of data properties.  One property per dataset rather than one property per trace (as is true for tracepropertydefs).\naxis_propdefs::Vector{TracePropertyDef} Trace properties corresponding to the CloudSeis axes.  If not set, then SAMPLE, TRACE, FRAME, VOLUME and HYPRCUBE are used.\naxis_units::Vector{String} Units corresponding to the CloudSeis axes. e.g. SECONDS, METERS, etc.  If not set, then UNKNOWN is used.\naxis_domains::Vector{String} Domains corresponding to the CloudSeis axes. e.g. SPACE, TIME, etc.  If not set, then UNKNOWN is used.\naxis_pstarts::Vector{Float64} Physical origins for each axis.  If not set, then 0.0 is used for the physical origin of each axis.\naxis_pincs::Vector{Float64} Physical deltas for each axis.  If not set, then 1.0 is used for the physical delta for each axis.\naxis_lstarts::Vector{Int} Logical starts for each axis.  If not set, then 1 is used for the logical start for each axis.\naxis_lincs::Vector{Int} Logical increments for each axis.  If not set, then 1 is used for the logical increment for each axis.\ncompressor=\"leftjustify\" Compress the cache before writing to disk.  This is particularly useful for data with variable fold.  chooose from: (\"none\", \"blosc\", \"leftjustify\", \"zfp\", \"cvx\")\ncompressor_options=() Pass options as key-word arguments to the compression algorithm.  Currently, only \"zfp\" and \"cvx\" have options[1]\n\nExample\n\nAzure storage\n\nusing AzStorage, CloudSeis\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container, \"w\"; axis_lengths=[10,11,12], axis_pincs=[0.004,10.0,20.0])\nclose(io)\n\nPOSIX storage\n\nusing AzStorage, FolderStorage\ncontainer = Folder(\"mydataset-cs\")\nio = csopen(container, \"w\"; axis_lengths=[10,11,12], axis_pincs=[0.004,10.0,20.0])\n\nNotes\n\nWhen using the similarto option, one can change the number of dimensions of the data-set via axis_lengths.  If one shrinks the number of dimensions,\n\nthen various data-set properties (e.g. axis_units) will be truncated.  The truncation can be customized by using appropriate key-word arguments.\n\nThe zfp compression options are tol, precision and rate.  So, for example:\n\nusing AzStorage, CloudSeis\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageacccount\")\nio = csopen(container, \"w\"; axis_lengths=[10,11,12], compressor=\"zfp\", compressor_options=(tol=1e-4,))\n\nPlease refer to ZFPCompressor.jl for more information.  If compressor_options is not supplied, then the defaults are (precision=16,).  Also, note that compressor_options=() results in ZFP lossless compression.  ZFP lossless compression will be used for the headers and foldmap regardless of the choice of compressor_options.\n\nThe cvx compression options are b1, b2, b3 and scale.  So, for example:\n\n\n\nPlease refer to CvxCompress.jl for more information.  If compressor_options is no supplied, then the defaults are (b1=16,b2=16,b3=16,scale=1e-2).\n\nThe history dictionary must follow a specific structure.  One can get the history from an existing data-set via history(io::CSeis), and can\n\nconstruct and/or agument history via history!.  In general the structure is,\n\nDict(\n    \"inputs\" => [\n        Dict(\n            \"container\" => container, # dictionary describing where the input data-set is.\n            \"history\" => history dictionary that, recursively, embeds the history of the input data-set.\n        )\n    ],\n    \"flow\" => Dict(\n        \"flow\" => Dict(\n            \"parameters\" => flowparameters, # dictionary describing parameters that apply to all processes\n            \"processes\" => [\n                \"process\" => process, # dictionary or string that uniquely locates the process run\n                \"parameters\" => parameters # dictionary describing parameters passed to the process\n            ]\n        )\n    )\n)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.dataproperty-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"CloudSeis.dataproperty","text":"dataproperty(io::CSeis, name[, default_value])\n\nReturn the CloudSeis data property with name that is in the CloudSeis data-set io.  If default_value is provided and a property with name does not exist, then return default_value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.description!-Tuple{CloudSeis.CSeis}","page":"Reference","title":"CloudSeis.description!","text":"description!(io::CSeis, kwargs...)\n\nLimited mutation of the properties of an existing CloudSeis dataset.\n\nOptional key-word arguments\n\naxis_lengths = nothing  Grow the size of the axis lengths (3rd dimension and higher)[1].\n\nNotes\n\n[1] axis_lengths must be the same length as size(io).  In addition, prod(axis_lengths[3:end])\n\nmust be greater than prod(size(io)[3:end]) and axis_lengths[i] must equal size(io,i) for iâˆˆ(1..ndims(io)-1).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.foldmap-Tuple{CloudSeis.CSeis}","page":"Reference","title":"CloudSeis.foldmap","text":"foldmap(io; all=false, nasync=2048, showprogress=false)\n\nReturn the foldmap for either the currently cached extent (if all=false) or the entire dataset if all=true.  If all=true, then the operation is performed using an asynchronous map over the extents.  The number of asynchronous tasks in this map is controled by nasync.  Use showprogress=true to display a progress bar while loading the foldmap.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.hasdataproperty-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"CloudSeis.hasdataproperty","text":"hasdataproperty(io::CSeis, name)\n\nReturn true if the data property called name exists in io.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.headerlength-Tuple{CloudSeis.CSeis}","page":"Reference","title":"CloudSeis.headerlength","text":"headerlength(io::CSeis)\n\nReturns the length (number of bytes) of a trace header for a CloudSeis data-set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.history!","page":"Reference","title":"CloudSeis.history!","text":"h = history!([io::CSeis|history::Dict]; kwargs...)\n\nMutate the history of an existing CloudSeis dataset or dictionary, or create a new history dictionary.\n\noptional key-word arguments\n\nprocess=\"\" name of a process that was run in a flow that produced the data-set.\nprocess_parameters=Dict() process parameters.\nflow_parameters=Dit() flow parameters.\n\nNotes\n\nIf more than one process was run (e.g. a flow of processes) to produce the data-set, then call history! in the\n\norder that the processes were run.\n\nThe history can be passed to the csopen and cscreate methods via the history key-word argument.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TeaSeis.allocframe-Tuple{CloudSeis.CSeis}","page":"Reference","title":"TeaSeis.allocframe","text":"trcs,hdrs = allocframe(io::CSeis)\n\nAllocate and return memory to store traces and trace headers for a single frame.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.allocframehdrs-Tuple{CloudSeis.CSeis}","page":"Reference","title":"TeaSeis.allocframehdrs","text":"hdrs = allocframehdrs(io::CSeis)\n\nAllocate and return memory to store trace headers for a single frame.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.allocframetrcs-Tuple{CloudSeis.CSeis}","page":"Reference","title":"TeaSeis.allocframetrcs","text":"trcs = allocframetrcs(io::CSeis)\n\nAllocate and return memory to store traces for a single frame.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.domains-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"TeaSeis.domains","text":"domains(io::CSeis[,i])\n\nReturn the domain for the data-context axes. If i is specified, then return the domain for the ith data-context axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.fold-Tuple{CloudSeis.CSeis, CartesianIndex}","page":"Reference","title":"TeaSeis.fold","text":"fold(io::CSeis, i)\n\nReturn the fold of a CloudSeis frame corresponding, and where the frame is described by its index i.  The frame index can be either an Int, a VarArg{Int}, or a CartesianIndex.\n\nExample\n\nio = csopen(\"foo.cs\", \"w\"; axis_lengths=[10,11,12])\nfold(io, 5, 6) # fold corresponding to 5th frame and 6th volume\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.geometry-Tuple{CloudSeis.CSeis}","page":"Reference","title":"TeaSeis.geometry","text":"geometry(io::CSeis)\n\nReturn the geometry (if any) associated with the CloudSeis data-set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.leftjustify!-Tuple{CloudSeis.CSeis, AbstractMatrix{Float32}, AbstractMatrix{UInt8}, Integer}","page":"Reference","title":"TeaSeis.leftjustify!","text":"leftjustify!(io::CSeis, trcs, hdrs)\n\nThis is primarily used for compression, but one can also use this as a convenience method to move all live traces to the beginning of its frame.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.leftjustify!-Tuple{CloudSeis.CSeis, AbstractMatrix{UInt8}, Integer}","page":"Reference","title":"TeaSeis.leftjustify!","text":"leftjustify!(io::CSeis, hdrs)\n\nConvenience method to move all live traces to the beginning of its frame.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.lincs-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"TeaSeis.lincs","text":"lincs(io::CSeis[,i])\n\nReturn the logical increment for the data-context axes. If i is specfied, then return the logical increment for the ith data-context axis\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.lstarts-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"TeaSeis.lstarts","text":"lstarts(io::CSeis[,i])\n\nReturn the logical start for the data-context axes. If i is specfied, then return the logical start for the ith data-context axis\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.pincs-Tuple{CloudSeis.CSeis}","page":"Reference","title":"TeaSeis.pincs","text":"pincs(io::CSeis[,i])\n\nReturn the physical increment for the data-context axes. If i is specified, then return the physical increment for the ith data-context axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.prop-Tuple{CloudSeis.CSeis, Symbol}","page":"Reference","title":"TeaSeis.prop","text":"prop(io::CSeis, propertydef)\n\nGiven a property definition propertydef, return a trace property corresponding to the CloudSeis data-set.  propertydef can either be a string or a TracePropertyDef.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.propdefs-Tuple{CloudSeis.CSeis}","page":"Reference","title":"TeaSeis.propdefs","text":"propdefs(io::CSeis[,i])\n\nReturn the property definitions corresponding to the data-context axes. If i is specified, then return the property definition for the ith data-context axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.props-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"TeaSeis.props","text":"props(io::CSeis[,i])\n\nReturn the trace property corresponding to the data-context axes. If i is specified, then return the property for the ith data-context axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.pstarts-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"TeaSeis.pstarts","text":"pstarts(io::CSeis[,i])\n\nReturn the physical start for the data-context axes. If i is specified, then return the physical start for the ith data-context axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readframe!-Tuple{CloudSeis.CSeis, AbstractArray, AbstractMatrix{UInt8}, CartesianIndex}","page":"Reference","title":"TeaSeis.readframe!","text":"readframe!(io::CSeis, trcs, hdrs, idx...; regularize=true)\n\nRead traces and headers from io into trcs::Matrix, and hdrs::Matrix for the frame idx.... idx... can either be integer(s) or a CartesianIndex.\n\nThe regularize named argument is only applicable when the compression method is LeftJustifyCompressor.  If set to true, then traces are  regularized to their correct context locations.  Otherwise, they remain left justified.  Note that one can subsequently use the regularize! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readframe-Tuple{CloudSeis.CSeis, CartesianIndex}","page":"Reference","title":"TeaSeis.readframe","text":"trcs,hdrs = readframe(io::CSeis, idx...; regularize=true)\n\nRead traces and headers from io for the frame idx....  idx... can either be integer(s) or a CartesianIndex.\n\nThe regularize named argument is only applicable when the compression method is LeftJustifyCompressor.  If set to true, then traces are  regularized to their correct context locations.  Otherwise, they remain left justified.  Note that one can subsequently use the regularize! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readframehdrs!-Tuple{CloudSeis.CSeis, AbstractMatrix{UInt8}, CartesianIndex}","page":"Reference","title":"TeaSeis.readframehdrs!","text":"readframehdrs!(io::CSeis, trcs, idx...; regularize=true)\n\nRead headers from io into hdrs::Matrix for the frame idx.... idx... can either be integer(s) or a CartesianIndex.\n\nThe regularize named argument is only applicable when the compression method is LeftJustifyCompressor.  If set to true, then traces are  regularized to their correct context locations.  Otherwise, they remain left justified.  Note that one can subsequently use the regularize! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readframehdrs-Tuple{CloudSeis.CSeis, CartesianIndex}","page":"Reference","title":"TeaSeis.readframehdrs","text":"hdrs = readframehdrs(io::CSeis, idx...; regularize=true)\n\nRead headers from io for the frame idx....  idx.. can either be integer(s) or a CartesianIndex.\n\nThe regularize named argument is only applicable when the compression method is LeftJustifyCompressor.  If set to true, then traces are  regularized to their correct context locations.  Otherwise, they remain left justified.  Note that one can subsequently use the regularize! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readframetrcs!-Tuple{CloudSeis.CSeis, AbstractArray, CartesianIndex}","page":"Reference","title":"TeaSeis.readframetrcs!","text":"readframetrcs!(io::CSeis, trcs, idx...[; regularize=true])\n\nRead traces from io into trcs::Matrix for the frame idx.... idx... can either be integer(s) or a CartesianIndex.\n\nThe regularize named argument is only applicable when the compression method is LeftJustifyCompressor.  If set to true, then traces are  regularized to their correct context locations.  Otherwise, they remain left justified.  Note that one can subsequently use the regularize! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readframetrcs-Tuple{CloudSeis.CSeis, CartesianIndex}","page":"Reference","title":"TeaSeis.readframetrcs","text":"trcs = readframetrcs(io::CSeis, idx...; regularize=true)\n\nRead traces from io for the frame idx....  idx.. can either be integer(s) or a CartesianIndex.\n\nThe regularize named argument is only applicable when the compression method is LeftJustifyCompressor.  If set to true, then traces are  regularized to their correct context locations.  Otherwise, they remain left justified.  Note that one can subsequently use the regularize! method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readhdrs!-Union{Tuple{N}, Tuple{CloudSeis.CSeis, AbstractArray, Vararg{Union{Colon, Int64, AbstractRange{Int64}}, N}}} where N","page":"Reference","title":"TeaSeis.readhdrs!","text":"readhdrs!(io::CSeis, hdrs, rng...)\n\nRead trace headers from io into hdrs::AbstractArray, and where the size and dimension of hdrs must correspond to the range specification in rng....  Unlike readtrcs!, we always read the entirity of each trace header.  Therefore, the first range specifier must be :.\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nsize(io) # (100,101,102)\nhdrs = readhdrs!(io, Array{Float32,3}(undef,headerlength(io),101,1), :, :, 1)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readhdrs-Union{Tuple{N}, Tuple{CloudSeis.CSeis, Vararg{Union{Colon, Int64, AbstractRange{Int64}}, N}}} where N","page":"Reference","title":"TeaSeis.readhdrs","text":"readhdrs(io::CSeis, rng...)\n\nRead trace headers from io.  Unlike readtrcs!, we always read the entirity of each trace header.  Therefore, the first range specifier must be :.\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nsize(io) # (100,101,102)\nhdrs = readhdrs(io, :, :, 1)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readtrcs!-Union{Tuple{N}, Tuple{CloudSeis.CSeis, AbstractArray, Vararg{Union{Colon, Int64, AbstractRange{Int64}}, N}}} where N","page":"Reference","title":"TeaSeis.readtrcs!","text":"readtrcs!(io::CSeis, trcs, rng...)\n\nRead traces from io into trcs::AbstractArray, and where the size and dimension of trcs must correspond to the range specification in rng....\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nsize(io) # (100,101,102)\ntrcs = readtrcs!(io, Array{Float32,3}(undef,50,101,1), 1:50, :, 1)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.readtrcs-Union{Tuple{N}, Tuple{CloudSeis.CSeis, Vararg{Union{Colon, Int64, AbstractRange{Int64}}, N}}} where N","page":"Reference","title":"TeaSeis.readtrcs","text":"readtrcs(io::CSeis, trcs, rng...)\n\nRead traces from io for the specified rng....\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nsize(io) # (100,101,102)\ntrcs = readtrcs(io, 1:50, :, 1)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.regularize!-Tuple{CloudSeis.CSeis, Any, AbstractMatrix{Float32}, AbstractMatrix{UInt8}}","page":"Reference","title":"TeaSeis.regularize!","text":"regularize!(io::CSeis[, fld], trcs, hdrs)\n\nThis is primarily used for compression, but one can also use this as a convenience method undo the effect of leftjustify!, moving traces from the beginning of the frame to their recorded trace location.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.set!-Tuple{CloudSeis.TraceProperty, AbstractMatrix{UInt8}, Integer, Any}","page":"Reference","title":"TeaSeis.set!","text":"set!(prop::TraceProperty, hdrs::Matrix, i, value)\n\nSet the vale of the header property for the ith column of hdrs.\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nhdrs = readframehdrs(io, 1)\nset!(prop(io, \"TRACE\"), hdr, 1, 2)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.set!-Union{Tuple{T}, Tuple{CloudSeis.TraceProperty{T}, AbstractVector{UInt8}, Any}} where T","page":"Reference","title":"TeaSeis.set!","text":"set!(prop::TraceProperty, hdr::Vector, value)\n\nSet the vale of a trace header property for the hdr.\n\nExample\n\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container)\nhdrs = readframehdrs(io, 1)\nhdr = @view hdrs[:,1]\nset!(prop(io, \"TRACE\"), hdr, 1)\nclose(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.units-Tuple{CloudSeis.CSeis, Any}","page":"Reference","title":"TeaSeis.units","text":"units(io::CSeis[,i])\n\nReturn the physical unit for the data-context axes. If i is specfied, then return the physical unit for the ith data-context axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.writeframe-Tuple{CloudSeis.CSeis, AbstractArray, AbstractMatrix{UInt8}}","page":"Reference","title":"TeaSeis.writeframe","text":"writeframe(io::CSeis, trcs, hdrs)\n\nWrite a frame to io.  The location of the frame is determined by the axis headers set in hdrs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TeaSeis.writeframe-Tuple{CloudSeis.CSeis, AbstractArray, CartesianIndex}","page":"Reference","title":"TeaSeis.writeframe","text":"writeframe(io::CSeis, trcs, idx...)\n\nWrite a frame to io.  The location of the frame is determined from idx... which can either be integer(s) or a CartesianIndex.  A minimal set of headers are created from idx... and are also written to io.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.Geometry-Tuple{}","page":"Reference","title":"CloudSeis.Geometry","text":"g = Geometry([;kwargs...])\n\nReturns a geometry object associated with the CloudSeis data-set.  This includes an origin (o) and three orthogonal vectors (u,v,w).  In addition, one can specify how azimuth is defined for TTI earth models by giving a specific direction for positive azimuth, and the axis from which it is measured.  This can be useful when describing the orientation of a model in three dimensional space.\n\nkey-word arguments\n\nox=0,oy=0,oz=0 grid origin\nux=0,uy=0,uz=1 u vector such that the end of the u axis is at the point (ox+ux,oy+uy,oz+uz)\nvx=0,vy=0,vz=1 v vector such that the end of the u axis is at the point (ox+vx,oy+vy,oz+vz)\nwx=0,wy=0,wz=1 w vector such that the end of the u axis is at the point (ox+wx,oy+wy,oz+wz)\nu1=1,un=2 integer end-points (u axis) that can be used to describe a grid (e.g. for finite difference)\nv1=1,vn=2 integer end-points (v axis) that can be used to describe a grid (e.g. for finite difference)\nw1=1,wn=2 integer end-points (w axis) that can be used to describe a grid (e.g. for finite difference)\nx_direction=\"east\" compass direction that 'x' is parallel to\ny_direction=\"north\" compass direction that 'y' is parallel to\nz_direction=\"depth\" compass direction that 'z' is parallel to\ntti_angle_units=\"degrees\" for TTI models specify if the tilt and azimuth angles are stored in (\"degrees\", \"radians\", or \"unknown\")\ntti_azimuth_positive_direction=\"counter clockwise\" for TTI models, define the orientation of the azimuth (\"clockwise\", \"counter clockwise\" or \"unknown\")\ntti_azimuth_origin_axis=\"v\" for TTI models, define the axis from which azimuth is measured and at which azimuth is 0 (choose from: \"u\", \"v\", \"w\", \"x\", \"y\", \"-u\", \"-v\", \"-w\", \"-x\", \"-y\" or \"unknown\")\ntti_symmetry_axis_z_direction=\"elevation\" for TTI models, define if the projection of the normal to the symmetry axis onto z = (0,0,1) point up (elevation) or down (depth)\n\nnotes\n\nthis method does not check to see if the u,v,w vectors are orthogonal\nfor models that do not required azimuthal anisotropy (e.g. isotropic, VTI), it is convenient to set tti_azimumth_positive_direction and tti_azimuth_origin_axis to \"unknown\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#CloudSeis.LogicalIndices","page":"Reference","title":"CloudSeis.LogicalIndices","text":"I = LogicalIndices(io::CSeis)\n\nReturns a construct similar to CartesianIndices that allows conversion from linear indices to cartesian indices that are offest by the logical starts and deltas of the CloudSeis data context.  In addition, LogicalIndices implements iteration for looping over all frames in a data-set.  For example,\n\nio = csopen(AzContainer(\"foo\"; storageaccount=\"bar))\nidx = LogicalIndices(io)[2] # get the index corresponding to the second frame in the data-set.\nfor idx in LogicalIndices(io)\n    @show idx\n    trcs, hdrs = getframe(io, idx)\nend\n\n\n\n\n\n","category":"type"},{"location":"#CloudSeis.jl","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"CloudSeis.jl is a Julia library for reading and writing CloudSeis files.  The CloudSeis data format is designed to be similar to the JavaSeis[1] data format while adapting to cloud storage (e.g. Azure Blob Storage).  CloudSeis.jl works-a-round cloud storage latency issues using a caching layer.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"[1] https://github.com/ChevronETC/TeaSeis.jl","category":"page"},{"location":"#Quick-start-example","page":"CloudSeis.jl","title":"Quick start example","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"# load the library\nusing AzStorage, CloudSeis, FolderStorage\n\n# create a new CloudSeis file from an Azure container.  Use a 3D framework (128 samples per trace, 32 traces per frame, and 16 frames per volume)\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container, \"w\", axis_lengths=[128, 32, 16])\n\n# alternatively, create a new CloudSeis file for POSIX storage\n#=\ncontainer = Folder(\"filename-cs\")\nio = csopen(container, \"w\", axis_lengths=[128, 32, 16])\n=#\n\n# allocate traces and headers for a single frame\ntrcs, hdrs = allocframe(io)\n\n# populate trcs and hdrs with values\nfor i = 1:size(io,2)\n  set!(prop(io, stockprop[:TRC_TYPE]), hdrs, i, tracetype[:live])\n  set!(prop(io, stockprop[:TRACE]), hdrs, i, i)\n  set!(prop(io, stockprop[:FRAME]), hdrs, i, 1)\nend\nrand!(trcs)\n\n# write trcs,hdrs the data-set\nwriteframe(io, trcs, hdrs)\n\n# close the file (this will also flush buffers to block storage as needed)\nclose(io)\n\n# open a CloudSeis dataset from an existing container.\nio = csopen(container)\n\n# read the first frame:\ntrcs, hdrs = readframe(io, 1) # out-of-place read\nreadframe!(io, trcs, hdrs) # in-place read\n\n# access values stored in a trace property in the first trace of the frame\nget(prop(io, stockprop[:TRACE]), hdrs, 1)\n\n# close the file\nclose(io)","category":"page"},{"location":"#csopen-/-cscreate","page":"CloudSeis.jl","title":"csopen / cscreate","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"A CloudSeis dataset is created/opened with the csopen or cscreate methods which return a CSeis.  A CloudSeis dataset must have a minimum of 3 dimensions.  For example:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"using AzStorage, CloudSeis\n\n# create a 3D CloudSeis dataset with 10  samples per trace, 11 traces per frame and 12 frames per volume\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\nio = csopen(container, \"w\", axis_lengths=[10,11,12])\n\n# open an existing dataset in read-only model\nio = csopen(container, \"r\")\nio = csopen(container) # equivalent to previous line\n\n# open an existing dataset for reading and writing\nio = csopen(container, \"r+\")\n\n# close an open dataset\nclose(io)\n\n# create a dataset without returning a handle or opening the data\ncscreate(container, axis_lengths=[10,11,12])","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"The cscreate method is useful, for example, when you need to create the dataset on the master process and write to it on worker processes.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"It is also possible to pass a list of containers to csopen and cscreate.  In this case the extents are distributed across all containers, and the meta-information is in the first container in the list.  This is, typically, used to manually shard data across multiple Azure storage accounts in order to improve through-put.  For example:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"containers = [AzContainer(\"filename-cs\"; storageaccount=\"mystorageaccount$i\") for i = 1:10]\nio = csopen(containers, \"w\", axis_lengths=[10,11,2])","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Note that when opening a data-set that is sharded accross multiple containers in \"r\" or \"r+\" modes only the primary container that contains description.json needs to be provided.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"csopen and cscreate take a number of keyword arguments to control behavior.  Please see the reference section in this documentation for more information.","category":"page"},{"location":"#Read/write-methods","page":"CloudSeis.jl","title":"Read/write methods","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"CloudSeis is a frame based file format.  For io::CSeis, allocate memory for a single frame:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"trcs, hdrs = allocframe(io) # allocate memory for traces and headers for a single frame\ntrcs = allocframetrcs(io) # allocate memory for traces for a single frame\nhdrs = allocframehdrs(io) # allocate memory for headers for a single frame","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Read a frame. ifrm::Int, ivol::Int, ihyp::Int and i6::Int must be consistent with the CloudSeis data context.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"trcs, hdrs = readframe(io, ifrm) # read from 3D data\ntrcs, hdrs = readframe(io, ifrm, ivol) # read from 4D data\ntrcs, hdrs = readframe(io, ifrm, ivol, ihyp) # read from 5D data\ntrcs, hdrs = readframe(io, ifrm, ivol, ihyp, i6) # read from 6D data\n...","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Read a frame (in-place) using pre-allocated memory:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"readframe!(io, trcs, hdrs, ifrm)                # read from 3D data\nreadframe!(io, trcs, hdrs, ifrm, ivol)          # read from 4D data\nreadframe!(io, trcs, hdrs, ifrm, ivol, ihyp)    # read from 5D data\nreadframe!(io, trcs, hdrs, ifrm, ivol, ihyp, i6) # read from 6D data\n...","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Similar method exist for reading only headers:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"hdrs = readframehdrs(io, ifrm) # read from 3D data\nhdrs = readframehdrs(io, ifrm, ivol) # read from 4D data\n...\nreadframehdrs!(io, hdrs, ifrm) # in-place read from 3D data\nreadframehdsr!(io, hdrs, ifrm, ivol) # in-place read from 4D data\n...","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"or only traces:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"trcs = readframetrcs(io, ifrm) # read from 3D data\ntrcs = readframetrcs(io, ifrm, ivol) # read from 3D data\n...\nreadframetrcs!(io, trcs, ifrm) # in-place read from 3D data\nreadframetrcs!(io, trcs, ifrm, ivol) # in-place read from 4D dadta\n...","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Write a frame.  The frame, volume, etc. indices are determined from the trace properties.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"writeframe(io, trcs, hdrs)","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"To loop over all frames in a dataset of arbitrary dimensions, use LogicalIndices:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"for idx in LogicalIndices(io)\n  trcs, hdrs = readframe(io, idx)\nend","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Of course, this can also be used with readframe!, readframetrcs, readframetrcs!, readframehdrs and readframehdrs!.","category":"page"},{"location":"#Fold","page":"CloudSeis.jl","title":"Fold","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Methods for finding the fold of a frame","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"fold(io, hdrs) # get fold by examining `hdrs` from a frame\nfold(io, ifrm) # get fold for a 3D data-set using the `TraceMap`\nfold(io, ifrm, ivol) # get fold for a 4D data-set using the `TraceMap`\n...","category":"page"},{"location":"#Alternative-read/write-methods-(N-dimensional-slices)","page":"CloudSeis.jl","title":"Alternative read/write methods (N-dimensional slices)","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"We supply convenience methods for reading and writing arbitrary patches of data.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Reading","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"trcs,hdrs = read(io, 1:10, 2:3, 4) # read from 3D dataset (frame 4, traces 2-3 and time samples 1-10)\ntrcs,hdrs = read(io, 1:10, 2:3, 4, :) # read from a 4D data-set (all volumes, frame 4, traces 2-3, and time samples 1-10)\n...\nread!(io, trcs, hdrs, 1:10, 2:3, 4) # in-place read from 3D data\n...","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Similar methods exist for reading only traces:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"trcs = readtrcs(io, 1:10, 2:3, 4)\nreadtrcs!(io, trcs, 1:10, 2:3, 4) # in-place version of previous line","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"and only headers:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"hdrs = readhdrs(io, 1:10, 2:3, 4)\nreadhdrs!(io, hdrs, 1:10, 2:3, 4) # in-place version of previous line","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Writing","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"write(io, trcs, hdrs) # trcs::Array{Float32,N}, hdrs::Array{UInt8,N} where N>=3\nwrite(io, trcs, hdrs, 1:10) # same as previous except only time samples 1:10 are written","category":"page"},{"location":"#Alternative-write-methods-for-full-frames","page":"CloudSeis.jl","title":"Alternative write methods for full frames","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"The first set of APIs are for writing one frame at a time:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"writeframe(io, trcs, ifrm) # write to 3D data\nwriteframe(io, trcs, ifrm, ivol) # write to 4D data\n...","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"The second set of APIs are for writing arbitrary N-dimensional data:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"write(io, trcs, :, 1:10, 3:2:5) # write to 3D data, all samples; traces 1-10; frames 3,5\nwrite(io, trcs, :, 1:10, 3:2:5, 6) # write to 4D data, all samples; traces 1-10; frames 3,5; volume 6\n...","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Please note that in these forms, the writeframe and write methods will create headers for you, and populate the :TRC_TYPE property along with the properties corresponding to the trace and frame axes of your data.  In the case of 4D data, the volume property is also populated, and in the case of 5D data, the volume and hypercube properties are also populated.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"In addition, please note that in the write method, trcs must have the same number of dimensions as io.  In practice this can be accomplished using reshape. For example if size(io)=(10,20,3) and size(trcs)=(10,), then to write trcs to the first trace of the first frame of io one could write:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"write(io, rehsape(trcs, 10, 1, 1), :, 1, 1)","category":"page"},{"location":"#Reduction-(aggregation)-of-a-CloudSeis-data-set","page":"CloudSeis.jl","title":"Reduction (aggregation) of a CloudSeis data-set","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"There are scenarios where a CloudSeis data-set will consist of many small extents.  For example, if one is writing a CloudSeis data-set from many parallel processes and where each process is responsible for writing a small amount of data.  Subsequently, one may want to read the data-set from a single instance. In order to avoid latencies in this subsequent read, CloudSeis.jl provides a reduce method that aggregates frames into fewer extents.  For example:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"using Distributed, AzManagers\naddprocs(\"cbox16\", 16)\n@everywhere using CloudSeis\n\n# create a data-set with 16 frames and 1 frame per extent\ncontainer = AzContainer(\"mydataset-cs\"; storageaccount=\"mystorageaccount\")\ncscreate(container, \"w\", axis_lengths=[100,100,500], extents=[i:i for i=1:16])\n\n# each process writes to its own extent\n@sync for (ipid,pid) in enumerate(workers())\n  @spawnat pid begin\n    io = csopen(Bucket(\"test-cs\"), \"r+\")\n    writeframe(io, rand(Float32,100,100), ipid)\n  end\nend\n\n# reduce the number of extents such that each extent is about 1GB (GCP only)\nreduce(container, mbytes_per_extent=1000)\n\nrmprocs(workers())","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Please see the reference section of this documentation for more information.","category":"page"},{"location":"#Trace-Properties","page":"CloudSeis.jl","title":"Trace Properties","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"The CloudSeis data format does not specify any trace properties.  However, there are commonly used (stock) properties (see src/stockprops.jl).  It is unusual when a stock property does not suit your needs.  But, if need be, you can define a custom property using the TracePropertyDef constructor:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"pdef = TracePropertyDef(\"label\", \"description\", Float32)\npdef = TracePropertyDef(\"label\", \"description\", Vector{Float32}, 2)","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"The arguments to TracePropertyDef are the label, description, type, and, optionally, the number of elements stored in the property. The stock properties are defined in src/stockprops.jl using a Julia dictionary: stockprop.  For example, access a stock definition for the TRACE property:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"pdef = stockprop[:TRACE]","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Given a CloudSeis file io::CSeis and a stock definition, we can access the corresponding property of a CloudSeis file:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"p = prop(io, pdef) # access using a `TracePropertyDef`\np = prop(io, \"TRACE\") # alternatively, access using the trace property definition label\np = prop(io, \"TRACE\", Int32) # type-stable version of previous line","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Given, additionally, a frame of headers hdrs::Array{UInt8,2}, we can get and set the values stored in a property:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"@show get(p, hdrs, 1) # get trace property value for the first traces in `hdrs`\nset!(p, hdrs, 1, 5) # set the first header in `hdrs` to 5\nwriteframe(io, trcs, hdrs) # the CloudSeis file does not know about the updated header until you call `writeframe`","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"In the above code listing trcs is of type Array{Float32,2}.","category":"page"},{"location":"#TRC_TYPE","page":"CloudSeis.jl","title":"TRC_TYPE","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"The TRC_TYPE property is used to indicate if a trace is dead, live or auxiliary within any given frame.  It is stored as an Int.  We provide a second dictionary to map between the Int and human readable code:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"tracetype[:live]\ntracetype[:dead]\ntracetype[:aux]","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"For example,","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"io = csopen(\"file-cs\", \"r\")\ntrcs, hdrs = readframe(io, 1)\nprop_trctype = prop(io, stockprop[:TRC_TYPE])\nfor i=1:size(hdrs,2)\n    if get(prop_trctype, hdrs, i) == tracetype[:live]\n        write(STDOUT, \"trace $(i) is a live trace\\n\")\n    elseif get(prop_trctype, hdrs, i) == tracetype[:dead]\n        write(STDOUT, \"trace $(i) is a dead trace\\n\")\n    elseif get(prop_trctype, hdrs, i) == tracetype[:aux]\n        write(STDOUT, \"trace $(i) is a aux trace\\n\")\n    end\nend\nclose(io)","category":"page"},{"location":"#Data-properties","page":"CloudSeis.jl","title":"Data properties","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"CloudSeis.jl provides support for storing custom data properties.  This is accomplished by passing an array of DataProperty's to the csopen function. For example, a data property could be defined as:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"p = DataProperty(\"Survey date\", 120977)","category":"page"},{"location":"#Geometry","page":"CloudSeis.jl","title":"Geometry","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"CloudSeis.jl provides support for storing survey geometry using three-points to define rotated/translated coordinate system.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"geom = Geometry(u1=1,un=2,v1=1,vn=2,w1=1,wn=2,ux=1.0,uy=0.0,uz=0.0,vx=0.0,vy=1.0,vz=0.0,wx=0.0,wy=0.0,wz=1.0)","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"where (ox,oy,oz) is the origin, (ux,uy,uz) is a vector to define the end of the u-axis (e.g. cross-line axis), (vx,vy,vz) is the end of the v-axis (e.g. the in-line axis), and (wx,wy,wz) is the end of the w-axis (e.g. the depth axis).  (u1,un) are the first and last bin indices along the u-axis, (v1,vn) are the first and last bin indices along the v-axis, and (w1,wn) are the first and last bin indices along the w-axis.  CloudSeis.jl does not provide any tools for using this geometry to manipulate trace coordinates. I would recommend that this functionality be put into a separate package.","category":"page"},{"location":"#History","page":"CloudSeis.jl","title":"History","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"CloudSeis.jl provides support for storing processing history by recording the input data-set(s) and steps in the processing flow that resulted in a new data-set.  A step is defined as the process (program) that was run as well as the input parameters for that process.  The history is recursive in the sense that the history of input data-sets are embedded.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Example of creating a new history dictionary:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"h = history!(flow_parameters=Dict(\"one\"=>1))\nh = history!(h, process=\"myprocess1\", process_parameters=Dict(\"two\"=>2,\"three\"=>3))\nh = history!(h, process=\"myprocess2\", process_parameters=Dict(\"four\"=>4,\"five\"=>5))","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"We can then use that history in the construction of a new CloudSeis data-set,","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"io = csopen(Folder(\"file-1-cs\"), \"w\", axis_lengths=[12,11,10], history=h)\nhistory(io) # outputs the history as a dictionary\nclose(io)","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Finally, we can embed the history of file-1-cs into a new data-set,","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"io = csopen(Folder(\"file-1-cs\"))\nh = history!(process=\"myprocess3\", process_parameters=Dict(\"eight\"=>8,\"nine\"=>9), histories = [Folder(\"file-1-cs\")])\nclose(io)\nio = csopen(Folder(\"file-2-cs\"), \"w\"; axis_lengths=[12,11,10], history=h)\nusing JSON\nprint(json(history(io), 1))","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Then the history structure is:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"{\n \"flow\": {\n  \"parameters\": {},\n  \"processes\": [\n   {\n    \"parameters\": {\n     \"eight\": 8,\n     \"nine\": 9\n    },\n    \"process\": \"myprocess3\"\n   }\n  ]\n },\n \"inputs\": [\n  {\n   \"history\": {\n    \"flow\": {\n     \"parameters\": {\n      \"one\": 1\n     },\n     \"processes\": [\n      {\n       \"parameters\": {\n        \"two\": 2,\n        \"three\": 3\n       },\n       \"process\": \"myprocess1\"\n      },\n      {\n       \"parameters\": {\n        \"four\": 4,\n        \"five\": 5\n       },\n       \"process\": \"myprocess2\"\n      }\n     ]\n    }\n   },\n   \"container\": {\n    \"foldername\": \"/home/tqff/.julia/dev/CloudSeis/file-1-cs\"\n   }\n  }\n ]\n}","category":"page"},{"location":"#Convenience-methods-and-dictionaries","page":"CloudSeis.jl","title":"Convenience methods and dictionaries","text":"","category":"section"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"For convenience and consistency, we supply several dictionaries.  In addition to the dictionary for trace property definitions and trace type (both described above), there are dictionaries for data domain stockdomain, units stockunit, and data type stockdatatype.  All of these are listed in src\\stockprops.jl.","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Example usage within the csopen method:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"io = csopen(Bucket(\"file-cs\"), \"w\", axis_lengths=[12,11,10], axis_units=[stockunit[:SECONDS], stockunit[:METERS], stockunit[:METERS]], axis_domains=[stockdomain[:TIME], stockdomain[:SPACE], stockdomain[:SPACE], datatype=stockdatatype[:SOURCE])","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Several convenience methods are supplied for querying io::CSeis:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"ndims(io)              # returns `Int`, number of dimensions in the CloudSeis dataset\nlength(io)             # returns `Int`, the number of frames in the CloudSeis dataset, equivalent to `prod(size(io)[3:end])`\nsize(io)               # returns `NTuple{Int}`, size of CloudSeis dataset\nsize(io,i)             # returns `Int`, size of CloudSeis dataset along dimension `i::Int`\nprops(io)              # returns `NTuple{TraceProperty}`, trace property along all dimensions\nprops(io,i)            # returns `TraceProperty`, trace property along dimension `i::Int`\npropdefs(io)           # returns `NTuple{TracePropertyDef}`, trace property definition along all dimensions\npropdefs(io,i)         # returns `TracePropertyDef`, trace property along dimension `i::Int`\nunits(io)              # returns `NTuple{String}`, units along all dimensions\nunits(io,i)            # returns `String, unit along dimension `i::Int`\ndomains(io)            # returns `NTuple{String}`, data domains along all dimensions\ndomains(io,i)          # returns `String`, data domain along dimension `i::Int`\npstarts(io)            # returns `NTuple{Float64}`, physical starts along all dimensions\npstarts(io,i)          # returns `Float64`, physical start along dimension `i::Int`\npincs(io)              # returns `NTuple{Float64}`, physical increments along all dimensions\npincs(io,i)            # returns `Float64`, physical increment along dimension `i::Int`\nlstarts(io)            # returns `NTuple{Int}`, logical starts along all dimensions\nlstarts(io,i)          # returns `Int`, logical start along dimension `i::Int`\nlincs(io)              # returns `NTuple{Int}`, logical increments along all dimensions\nlincs(io,i)            # returns `Int`, logical increment along dimension `i::Int`\nin(prop,io)            # returns true if the trace property `prop` exists in `io` --  `prop` can be of types `::TraceProperty`, `::TracePropertyDef`, or `::String`\ndataproperty(io,nm)    # returns the value held in the data property: `nm::String`\nhasdataproperty(io,nm) # returns true if the data property corresponding to label `nm::String` is in `io::CSeis`\ngeometry(io)           # returns `Geometry`, the stored geometry of the dataset.  If no geometry is stored, `nothing` is returned","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"Convenience methods are supplied for manipulating io::CSeis:","category":"page"},{"location":"","page":"CloudSeis.jl","title":"CloudSeis.jl","text":"rm(io) # remove (delete) the file and all of its extent files and secondary folders\nempty!(io)  # remove extends and secondary folders, but keep meta-data\ncp(src, dst) # create a new CloudSeis file `dst::AbstractString` that is a copy of `src::CSeis`, optional named argument: `secondaries=` - change file extents location\nmv(src, dst)  # move a CloudSeis file to `dst::AbstractString` from `src::CSeis`, optional named argument: `secondaries=` - change file extents location\ncopy!(io, hdrs, io1, hdrs1) # (not-implemented) copy values from `hdrs1::Array{UInt8,2}` to `hdrs::Array{UInt8,2}`\nreduce(io::CSeis[; mbytes_per_extent=1000, frames_per_extent=0, maxinstances=100, instancetemplate=\"jbox08\", instancegroup=\"jbox\", retries=0, maxerrors=Inf]) # reduce the number of extents used to store data, GCP only","category":"page"}]
}
